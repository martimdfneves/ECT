//
// LSD.TOS, April 2018 (DO NOT REMOVE THIS LINE)
//
// Data for some pseudo-random number generators
//
// To compile this program run the following command on a terminal
//   cc -Wall -O2 -march=native pseudo_random_generator.c -o pseudo_random_generator
// Run it as follows
//   ./pseudo_random_generator -heavy [n] [seed]     # this produces the heavy architecture with n internal bits
//   ./pseudo_random_generator -light [n] [seed]     # this produces the light architecture with n internal bits
// (defaults: n = 48, seed = current time)
//
// Due to the Cayley-Hamilton theorem the light generators are equivalent to linear feedback shift register generators
//   (but allow the extraction of more than one bit at a time as the state bits appear to be better scrambled); in
//   particular, consecutive zeros appear in a "more random way"
//

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

//
// data types
//

typedef unsigned       int u32;
typedef unsigned long long u64;


//
// program configuration (fan-ins and fan-outs for the light architecture)
//

#define min_n       48u  // smallest possible number of internal bits of the pseudo random number generator
#define max_n       63u  // largest possible number of internal bits of the pseudo random number generator
#define min_fan_in   2u  // smallest allowed fan-in value
#define max_fan_in   4u  // largest allowed fan-in value
#define min_fan_out  2u  // smallest allowed fan-out value
#define max_fan_out  5u  // largest allowed fan-out value


//
// generator configuration (in such a small program we use some global variables!)
//

static u32 n;      // number of bits
static u64 period; // the largest possible period of the light pseudo-random sequence
static u64 f[16];  // the factors of the largest possible period of the light pseudo-random sequence
static u32 nf;     // the number of distinct prime factors of the largest possible period of the light pseudo-random sequence
static u32 seed;   // the pseudo random number generator seed (for this C program, not for the VHDL generators!)

static void factor_n(void)
{
  u64 d,p;
  u32 i;

  if(n < 8u || n < min_n || n > max_n || n >= 64u)
  {
    fprintf(stderr,"factor_n(): illegal n (%u)\n",n);
    exit(1);
  }
  period = (1ull << (n - 1)) - 1ull; period = 2ull * period + 1ull; // equal to 2^n-1
  p = period;
  nf = 0u;
  for(d = 3ull;d < (1ull << 32) && d * d <= p;d += 2ull)
    if(p % d == 0ull)
    {
      f[nf++] = d;
      do
        p /= d;
      while(p % d == 0ull);
    }
  if(p > 1ull)
    f[nf++] = p;
  fprintf(stderr,"Period: %llu [%llu",period,f[0]);
  for(i = 1u;i < nf;i++)
    fprintf(stderr,",%llu",f[i]);
  fprintf(stderr,"]\n");
}


//
// heavy generator (counter + multi-stage substitution-permutation network based on big P-boxes and many small S-boxes)
//
// strong features: (hopefully) unpredictable, Hamiltonian path
// weak features: many logic cells, possible routing problems
//

static void output_heavy_vhdl(void)
{
  u32 i,j,k,l,h_bits,stage,n_stages,order[max_n],s_box[16];
  u64 full_mask,avalanche_in[max_n],avalanche_out[max_n];
  char buffer[max_n + 64];

  if(n < 8u || n < min_n || n > max_n || n >= 64u || n % 4u != 0u)
  {
    fprintf(stderr,"output_heavy_vhdl(): illegal n (%u)\n",n);
    exit(1);
  }
  //
  // initializations
  //
  if(seed == 0u)
    seed = (u32)time(NULL);
  srandom((unsigned int)seed);
  h_bits = n / 2;
  n_stages = 10; // 6 stages are usually enough to achieve full avalanche effect (each last stage bit depends on ALL stage_0 bits) but we use more
  for(k = 0u;k < n;k++)
    order[k] = k;
  full_mask = 0ull;
  for(k = 0u;k < n;k++)
    full_mask |= avalanche_in[k] = 1ull << k;
  for(k = 0u;k < 16u;k++)
    s_box[k] = k;
  for(k = 0;k < h_bits;k++)
    buffer[k] = '0' + (char)(random() & 1);
  buffer[k] = '\0';
  //
  // produce VHDL code
  //
  printf("--\n");
  printf("-- Multi-stage substitution-permutation network (period=2^%u, data generated by c_code/pseudo_random_generator.c with n=%u and seed=%u)\n",n,n,seed);
  printf("--\n");
  printf("architecture heavy of pseudo_random_generator is\n");
  printf("  signal carry    : std_logic := '0';                      -- carry signal between the two halves of the counter\n");
  printf("  signal state_00 : std_logic_vector(%u downto 0) := SEED; -- the pseudo-random generator internal counter\n",n - 1u);
  for(stage = 1u;stage <= n_stages;stage++)
  {
    printf("  -- state %u and all relevant data to update it\n",stage);
    printf("  signal state_%02u : std_logic_vector(%u downto 0) := SEED; -- scrambling stage #%u\n",stage,n - 1u,stage);
    for(l = 0;l < n;l++)
    {
      if(l % 4u == 0u)
      { // new group of 4 S-boxes
        printf("  signal addr_%02ux_%02u : std_logic_vector(3 downto 0);\n",stage - 1u,l / 4u);
retry:  // scramble S-box (one to one map)
        for(k = 16u;k > 1u;k--)
        {
          i = (u32)random() % k;
          j = s_box[i];
          s_box[i] = s_box[k - 1u];
          s_box[k - 1] = j;
        }
        // make sure each output bit of the the new S-box depends on all input bits
        for(i = 1u;i < 16u;i <<= 1)
          for(j = 1u;j < 16u;j <<= 1)
          {
            // does the output bit with mask i depend on the input bit with mask j?
            for(k = 0u;k < 16u && ((s_box[k] & i) == 0u) == ((s_box[k ^ j] & i) == 0u);k++)
              ;
            if(k == 16u)
            { // no, it does not
              fprintf(stderr,"S-box not good enough (output bit does not depend on all input bits)\n");
              goto retry; // Holly shit! A goto statement!
            }
          }
        // make sure the S-box is nonlinear (in GF(2^4))
        for(i = 0u;i < 16u;i++)
        {
          for(j = 0u;j < 16u && (s_box[i] ^ s_box[j]) == s_box[i ^ j];j++)
            ;
          if(j == 16u)
          { // S-box is linear
            fprintf(stderr,"S-box not good enough (linear in a Galois field)\n");
            goto retry; // Holly shit! A goto statement!
          }
        }
#if 0
        // make sure the S-box is nonlinear (modulo 16)
        for(i = 0u;i < 16u;i++)
        {
          for(j = 0u;j < 16u && ((s_box[i] + s_box[j]) % 16) == s_box[(i + j) % 16];j++)
            ;
          if(j == 16u)
          { // S-box is linear
            fprintf(stderr,"S-box not good enough (linear modulo 16)\n");
            goto retry; // Holly shit! A goto statement!
          }
        }
#endif
      }
      i = 1u << (l % 4u); // bit position
      printf("  constant S_BOX_%02u_%02u : std_logic_vector(15 downto 0) := \"",stage,l);
      for(k = 0u;k < 16u;k++)
        printf("%s",((s_box[k] & i) == 0) ? "0" : "1");
      printf("\";\n");
    }
  }
  printf("begin\n");
  printf("  --\n");
  printf("  -- Output\n");
  printf("  --\n");
  printf("  rnd <= state_%02u(N_BITS-1 downto 0); -- warning: do not use in the very first %u clock cycles (not random enough)\n",n_stages,n_stages);
  printf("  --\n");
  printf("  -- S-box addresses (P-boxes)\n");
  printf("  --\n");
  for(stage = 1;stage <= n_stages;stage++)
  {
    for(k = n;k > 1u;k--)
    { // scramble input bit order
      i = (u32)random() % k;
      j = order[i];
      order[i] = order[k - 1u];
      order[k - 1] = j;
    }
    for(l = 0;l < n;l++)
    {
      if(l % 4u == 0u)
      {
        printf("  addr_%02ux_%02u <= ",stage - 1u,l / 4u);
        for(i = 0u;i < 4u;i++)
          printf("state_%02u(%2u)%s",stage - 1u,order[l + i],(i == 3u) ? ";\n" : " & ");
      }
      avalanche_out[l] = avalanche_in[order[l + 0u]] | avalanche_in[order[l + 1u]] | avalanche_in[order[l + 2u]] | avalanche_in[order[l + 3u]];
    }
    for(k = 0u;k < n;k++)
      avalanche_in[k] = avalanche_out[k]; // update avalanche data
    for(k = 0u;k < n && avalanche_in[k] == full_mask;k++)
      ;
    if(k == n)
      fprintf(stderr,"Full avalanche effect achieved on stage %u\n",stage);
  }
  if(k < n)
  {
    fprintf(stderr,"output_heavy_vhdl(): full avalanche effect not achieved!\n");
    exit(1);
  }
  printf("  --\n");
  printf("  -- State update\n");
  printf("  --\n");
  printf("  process(enable,clock) is\n");
  printf("  begin\n");
  printf("    if enable = '1' and rising_edge(clock) then\n");
  printf("      -- state 0 update (counter)\n");
  printf("      if state_00(%u downto 0) = \"%s\" then\n",h_bits - 1u,buffer);
  printf("        carry <= '1';\n");
  printf("      else\n");
  printf("        carry <= '0';\n");
  printf("      end if;\n");
  printf("      state_00(%u downto 0) <= std_logic_vector(unsigned(state_00(%u downto 0))+1);\n",h_bits - 1u,h_bits - 1u);
  printf("      if carry = '1' then\n");
  printf("        state_00(%u downto %u) <= std_logic_vector(unsigned(state_00(%u downto %u))+1);\n",n - 1u,h_bits,n - 1u,h_bits);
  printf("      end if;\n");
  for(stage = 1;stage <= n_stages;stage++)
  {
    printf("      -- state %u update (scramble bits using 4x4 S-boxes)\n",stage);
    for(l = 0;l < n;l++)
      printf("      state_%02u(%2u) <= S_BOX_%02u_%02u(to_integer(unsigned(addr_%02ux_%02u)));\n",stage,l,stage,l,stage - 1u,l / 4u);
  }
  printf("    end if;\n");
  printf("  end process;\n");
  printf("end heavy;\n");
}


//
// light generator (warped linear feedback shift register pseudo-random number generator)
//
// strong features: small number of logic cells
// weak features: predictable, not very random, possible mild routing problems
//
// Matrices with bit entries, with dimensions up to 64x64, are stored in an array of 64-bit integers
//

#define bit(x64,i)  (((x64) >> (i)) & 1ull)  // is bit i of x64 set?

static void copy(u64 a[max_n],u64 b[max_n])
{ // b = a;
  u32 i;

  for(i = 0u;i < n;i++)
    b[i] = a[i];
}

static int determinant(u64 a[max_n])
{
  u64 t,m[max_n];
  u32 i,j;

  copy(a,m);
  for(i = 0;i < n;i++)
  {
    //
    // find a non-zero entry in column i
    //
    for(j = i;j < n && bit(m[j],i) == 0ull;j++)
      ;
    if(j == n)
      return 0;
    //
    // exchange line i with line j (if necessary)
    //
    if(j > i)
    {
      t = m[i];
      m[i] = m[j];
      m[j] = t;
    }
    //
    // add line i to all subsequent lines that have a non-zero entry in column i
    //
    for(j = i + 1;j < n;j++)
      if(bit(m[j],i) != 0ull)
        m[j] ^= m[i];
  }
  return 1;
}

static void mult(u64 a[max_n],u64 b[max_n],u64 c[max_n])
{ // c = a * b
  u32 i,k;
  u64 t;

  if(c == a)
  {
    fprintf(stderr,"mult(): illegal c\n");
    exit(1);
  }
  for(i = 0u;i < n;i++)
  { // $c_{i,j} = \sum_{k=0}^{n-1} a_{i,k} b_{k,j}$, which implies that $c_{i,*} = \sum_{k=0}^{n-1} a_{i,k} b_{k,*}$
    t = 0ull;
    for(k = 0u;k < n;k++)
      if(bit(a[i],k) != 0ull)
        t ^= b[k];
      c[i] = t;
  }
}

static void power(u64 a[max_n],u64 b,u64 c[max_n])
{ // c = a^b; b > 0
  u64 m[max_n],t[max_n];

  copy(a,m);
  while((b % 2ull) == 0ull)
  {
    mult(m,m,t);
    copy(t,m);
    b >>= 1;
  }
  copy(m,c);
  while((b >>= 1) != 0ull)
  {
    mult(m,m,t);
    copy(t,m);
    if(b % 2ull != 0ull)
    {
      mult(m,c,t);
      copy(t,c);
    }
  }
}

static int is_identity(u64 a[max_n])
{
  u32 i;

  for(i = 0u;i < n;i++)
    if(a[i] != (1ull << i))
      return 0;
  return 1;
}

static int has_full_period(u64 a[max_n])
{
  u64 m[max_n];
  u32 i;

  if(determinant(a) == 0)
    return 0;
  power(a,period,m);
  if(is_identity(m) == 0)
    return 0;
  for(i = 0u;i < nf;i++)
  {
    power(a,period / f[i],m);
    if(is_identity(m) != 0)
      return 0;
  }
  return 1;
}

static void print_matrix(u64 *a)
{ // pari-gp syntax
  u32 i,j;

  printf("[");
  for(i = 0u;i < n;i++)
    for(j = 0u;j < n;j++)
    {
      printf("%s",(bit(a[i],j) != 0ull) ? "1" : "0");
      if(j < n - 1u)
        printf(",");
      else if(i < n - 1u)
        printf(";");
      else
        printf("]");
    }
}

static void test_matrix_operations(void)
{ // the output of this function should be fed to pari-gp
  u64 a[max_n],b[max_n],c[max_n],d[max_n];
  u32 i,j,t;
  u64 k;

  if(isatty(fileno(stdout)) != 0)
  {
    fprintf(stderr,"test_matrix_operations(): output to a terminal (should be piped to pari-gp)\n");
    exit(1);
  }
  printf("default(parisize,256*2^20);\n");
  for(n = min_n;n <= max_n;n++)
  {
    factor_n();
    printf("printf(\"%u: \");",n);
    for(t = 0u;t < 4u;t++)
    {
      for(i = 0u;i < n;i++)
      {
        a[i] = b[i] = 0ull;
        for(j = 0;j < n;j++)
        {
          a[i] <<= 1;
          if((u32)random() % 3 == 0u)
            a[i] |= 1ull;
          b[i] <<= 1;
          if((u32)random() % 3 == 0u)
            b[i] |= 1ull;
        }
      }
      mult(a,b,c);
      do
        k = (u64)(u32)random() % 1234567u;
      while(k == 0ull);
      power(a,k,d);
      printf("a=Mod("); print_matrix(a); printf(",2);t=lift(matdet(a))==%u;",determinant(a));
      printf("b=Mod("); print_matrix(b); printf(",2);t+=lift(matdet(b))==%u;",determinant(b));
      printf("c=Mod("); print_matrix(c); printf(",2);t+=lift(matdet(c))==%u;",determinant(c));
      printf("d=Mod("); print_matrix(d); printf(",2);t+=lift(matdet(d))==%u;",determinant(d));
      printf("t+=lift(a*b-c)==matrix(%u,%u);",n,n);
      printf("t+=lift(a^%llu-d)==matrix(%u,%u);",k,n,n);
      printf("printf(\"%%d\",t);");
    }
    printf("printf(\".\\n\");\n");
  }
}

static void find_light_generator(u64 M[max_n])
{ // M = generator
  u32 i,j,k,n_attempts,t_attempts,i_min_fan_in,i_max_fan_in,j_min_fan_out,j_max_fan_out,fan_in[max_n],fan_out[max_n];

  factor_n();
  if(seed == 0u)
    seed = (u32)time(NULL);
  srandom((unsigned int)seed);
  t_attempts = 3u * n * n;
  for(;;)
  {
    //
    // random matrix
    //
    i_min_fan_in = i_max_fan_in = j_min_fan_out = j_max_fan_out = 0u;
    for(k = 0u;k < n;k++)
    {
      M[k] = 0ull;
      fan_in[k] = fan_out[k] = 0u;
    }
    n_attempts = 0u;
    while(n_attempts < t_attempts)
    {
      n_attempts++;
      //
      // random row and column
      //
      i = (u32)random() % n; // left-hand side variable number (row number)
      j = (u32)random() % n; // right-hand side variable number (column number)
      if(bit(M[i],j) != 0ull)
        continue;
      if(fan_in[i] == max_fan_in || fan_out[j] == max_fan_out)
        continue;
      n_attempts = 0u;
      M[i] |= 1ull << j;
      //
      // update fan_in
      //
      fan_in[i]++;
      if(fan_in[i] > fan_in[i_max_fan_in])
        i_max_fan_in = i;
      if(i == i_min_fan_in)
      {
        for(k = 0u;k < n && fan_in[k] >= fan_in[i];k++)
          ;
        if(k < n)
          i_min_fan_in = k;
      }
      //
      // update fan_out
      //
      fan_out[j]++;
      if(fan_out[j] > fan_out[j_max_fan_out])
        j_max_fan_out = j;
      if(j == j_min_fan_out)
      {
        for(k = 0u;k < n && fan_out[k] >= fan_out[j];k++)
          ;
        if(k < n)
          j_min_fan_out = k;
      }
      //
      // try matrix
      //
      if(fan_in[i_min_fan_in] >= min_fan_in && fan_out[j_min_fan_out] >= min_fan_out && has_full_period(M) != 0)
        return; // found it!
    }
  }
}

static void output_light_vhdl(u64 M[max_n])
{
  u32 i,j,k,f;

  printf("--\n");
  printf("-- Warped linear feedback shift register pseudo-random number generator (period=2^%u-1)\n",n);
  printf("--\n");
  printf("architecture light of pseudo_random_generator is\n");
  printf("  constant ZERO       : std_logic_vector(%u downto 0) := (others => '0'); -- the zero constant\n",n - 1u);
  printf("  signal   state      : std_logic_vector(%u downto 0) := SEED;            -- the current pseudo-random generator state\n",n - 1u);
  printf("  signal   next_state : std_logic_vector(%u downto 0);                    -- the next pseudo-random generator state\n",n - 1u);
  printf("  signal   kick       : std_logic;                                        -- set to one if the state is zero\n");
  printf("begin\n");
  printf("  --\n");
  printf("  -- Output\n");
  printf("  --\n");
  printf("  rnd <= state(N_BITS-1 downto 0);\n");
  printf("  --\n");
  printf("  -- State update\n");
  printf("  --\n");
  printf("  process(enable,clock) is\n");
  printf("  begin\n");
  printf("    if enable = '1' and rising_edge(clock) then\n");
  printf("      if state = ZERO then -- this can only happen if SEED = ZERO or if there is a hardware error\n");
  printf("        kick <= '1';\n");
  printf("      else\n");
  printf("        kick <= '0';\n");
  printf("      end if;\n");
  printf("      state <= next_state;\n");
  printf("    end if;\n");
  printf("  end process;\n");
  printf("  --\n");
  printf("  -- Next state computation (data generated by c_code/pseudo_random_generator.c with n=%u and seed=%u)\n",n,seed);
  printf("  --\n");
  for(i = f = 0u;i < n;i++)
  {
    printf("  next_state(%2u) <=",i);
    for(j = k = 0u;j < n;j++)
      if(bit(M[i],j) != 0ull)
      {
        if(k != 0u)
          printf(" xor");
        printf(" state(%2u)",j);
        k++;
      }
    if(f == 0u && k < max_fan_in)
    {
      printf(" xor kick;     ");
      f = 1u;
      k++;
    }
    else
      printf(";");
    for(;k < max_fan_in;k++)
      printf("              ");
    for(j = k = 0u;j < n;j++)
      if(bit(M[j],i) != 0ull)
        k++;
    printf(" -- state(%2u) used %2u times\n",i,k);
  }
  if(f == 0u)
  {
    fprintf(stderr,"output_light_vhdl(): kick signal not used!\n");
    exit(1);
  }
  printf("end light;\n");
}

static void test_light_generator(void)
{
# define test_n         24u
# define xor            ^
# define next_state(i)  next_state[i]
# define state(i)       state[i]
# define kick           0u
  u32 i,j,c,*bitmap,state[test_n],next_state[test_n];

  bitmap = (u32 *)malloc((size_t)1 << (test_n - 3u)); // 8 bits in each byte
  if(bitmap == NULL)
  {
    fprintf(stderr,"test_light_generator(): out of memory\n");
    exit(1);
  }
  n = test_n;
  for(c = 0u;c < (1u << (n - 5u));c++)
    bitmap[c] = 0u;
  state[0] = 1u;
  for(c = 1u;c < n;c++)
    state[c] = 0u;
  c = 0u;
  for(;;)
  {
    //
    // compute new state
    //
    // the following state update equations were obtained by setting min_n to 24u, by compiling this program, by running the command
    //   ./pseudo_random_generator -light 24 1
    // and by removing all lines not starting with "  next_state(", by replacing "<=" by "=", and by replacing "--" with "//"
    //
    next_state( 0) = state( 1) xor state( 3) xor state( 9) xor state(13); // state( 0) used  5 times
    next_state( 1) = state( 1) xor state( 5) xor state(11) xor state(22); // state( 1) used  4 times
    next_state( 2) = state( 5) xor state( 8) xor state(13) xor state(21); // state( 2) used  5 times
    next_state( 3) = state( 0) xor state(10) xor state(15) xor state(23); // state( 3) used  5 times
    next_state( 4) = state( 0) xor state( 4) xor state( 8) xor state(20); // state( 4) used  3 times
    next_state( 5) = state( 7) xor state(10) xor state(18) xor state(21); // state( 5) used  4 times
    next_state( 6) = state( 3) xor state( 5) xor state( 8) xor state(19); // state( 6) used  3 times
    next_state( 7) = state( 0) xor state( 8) xor state(20) xor state(23); // state( 7) used  5 times
    next_state( 8) = state( 7) xor state(11) xor state(21) xor kick;      // state( 8) used  5 times
    next_state( 9) = state( 1) xor state(16) xor state(22) xor state(23); // state( 9) used  2 times
    next_state(10) = state( 1) xor state( 2) xor state(17) xor state(22); // state(10) used  4 times
    next_state(11) = state( 7) xor state(10) xor state(11) xor state(17); // state(11) used  5 times
    next_state(12) = state( 8) xor state(10) xor state(22);               // state(12) used  2 times
    next_state(13) = state(12) xor state(18) xor state(20) xor state(22); // state(13) used  3 times
    next_state(14) = state( 2) xor state(12) xor state(14) xor state(19); // state(14) used  5 times
    next_state(15) = state( 3) xor state( 6) xor state(14) xor state(15); // state(15) used  3 times
    next_state(16) = state( 9) xor state(16) xor state(19);               // state(16) used  2 times
    next_state(17) = state( 2) xor state( 5) xor state( 7) xor state(15); // state(17) used  3 times
    next_state(18) = state(11) xor state(13) xor state(19) xor state(23); // state(18) used  2 times
    next_state(19) = state( 6) xor state( 7) xor state(14) xor state(17); // state(19) used  5 times
    next_state(20) = state( 0) xor state( 2) xor state( 3) xor state( 4); // state(20) used  5 times
    next_state(21) = state( 0) xor state( 6) xor state(20) xor state(23); // state(21) used  3 times
    next_state(22) = state( 4) xor state(11) xor state(14) xor state(19); // state(22) used  5 times
    next_state(23) = state( 2) xor state( 3) xor state(14) xor state(20); // state(23) used  5 times
    //
    // record new state
    //
    for(i = j = 0u;i < n;i++)
    {
      state[i] = next_state[i];
      j += state[i] << i;
    }
    if((bitmap[j >> 5] & (1u << (j & 31u))) != 0u)
      break;
    bitmap[j >> 5] |= 1u << (j & 31u);
    c++;
  }
  if(c != (1u << n) - 1u)
  {
    fprintf(stderr,"test_light_generator(): unexpected period (%08X)\n",c);
    exit(1);
  }
  free(bitmap);
# undef test_n
# undef xor
# undef next_state
# undef state
# undef kick
}


//
// main program
//

int main(int argc,char **argv)
{
  u64 M[max_n];

  if(argc == 2 && strcmp(argv[1],"-tm") == 0)
  {
    test_matrix_operations();
    fprintf(stderr,"All is well!\n");
    return 0;
  }
  if(argc == 2 && strcmp(argv[1],"-tl") == 0)
  {
    test_light_generator();
    fprintf(stderr,"All is well!\n");
    return 0;
  }
  if(argc >= 2 && (strcmp(argv[1],"-heavy") == 0 || strcmp(argv[1],"-light") == 0))
  {
    n = 48u; // default value
    seed = 0u;
    if(argc >= 3)
      n = (u32)atoi(argv[2]);
    if(n < min_n)
      n = min_n;
    if(n > max_n)
      n = max_n;
    if(argc >= 4)
      seed = (u32)atoi(argv[3]);
    if(strcmp(argv[1],"-heavy") == 0)
      output_heavy_vhdl();
    else
    {
      find_light_generator(M);
      output_light_vhdl(M);
    }
    return 0;
  }
  fprintf(stderr,"usage: pseudo_random_generator -heavy [n] [seed]  # VHDL code for the heavy generator\n");
  fprintf(stderr,"       pseudo_random_generator -light [n] [seed]  # VHDL code for the light generator\n");
  fprintf(stderr,"       pseudo_random_generator -tm | gp -q     # test matrix operations\n");
  fprintf(stderr,"       pseudo_random_generator -tl             # test light generator\n");
  fprintf(stderr,"by default n is 48\n");
  fprintf(stderr,"by default seed is the current time stamp\n");
  return 0;
}
